{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Dapp Platform with Trustless Off-Chain Access</p> <p>Our passion is to connect transparency of a decentralized system and convenience of a centralized system. Kogarashi Network is a Dapp platform that allows trustless and low-cost interaction with the Internet. Dapp providers can build decentralized services closer to the real world by putting Internet data into smart contracts. Trustless Oracle extension allow smart contracts to deal with a variety of type and property of data ever before.</p>"},{"location":"#functionality","title":"Functionality","text":"<p>Kogarashi Network provides a Dapp development environment capable of access to Internet data and using it for smart contracts. Dapp providers decide which information resource is used and how to process response data. The smart contract can verify the following things.</p> <ul> <li>Internet data is fetched from the valid data resource</li> <li>Data is processed correctly</li> </ul>"},{"location":"#benefit","title":"Benefit","text":"<p>Existing off-chain Oracle service uses majority decision to verify the data thus Dapp providers need to pay expensive costs to ensure the reliability. It's a trade-off relationship between cost and reliability. However, Kogarashi Network uses protocol verification instead. It can realize cheap costs and reliability.</p> <p>Kogarashi Network also supports the Oracle function as a built-in development environment. Dapp providers don't need to connect the Dapp platform and Oracle service. These features realize a seamless development process.</p> <ul> <li>Development: Connection between the Dapp platform and Oracle service is unnecessary</li> <li>Operation: Getting data cost is cheap</li> </ul>"},{"location":"#future","title":"Future","text":"<p>Blockchain realized a global transparent trading system. Kogarashi Network extends the type and property of data used on smart contracts. Traditional blockchain use cases are limited in the financial area but Kogarashi Network realizes non-financial area use cases and Dapp services are closer to people's everyday life.</p>"},{"location":"elgamal/","title":"Elgamal","text":"<p>{{#include ../primitiv/elgamal/README.md}}</p>"},{"location":"encrypted_balance/","title":"Encrypted balance","text":"<p>{{#include ../pallets/encrypted_balance/README.md}}</p>"},{"location":"frequent_errors/","title":"Frequent Errors","text":"<p>The main errors happen during development of runtime pallet are followings.</p> <ul> <li>error: duplicate lang item in crate</li> <li>error: the wasm32-unknown-unknown target is not supported by default, you may need to enable the \"js\" feature</li> <li>error[E0603]: module \"group\" is private</li> <li>error[E0512]: cannot transmute between types of different sizes, or dependently-sized types</li> <li>error[E0432]: unresolved import sp_core::to_substrate_wasm_fn_return_value</li> <li>error: failed to parse manifest at failed to parse the version requirement '0.11 ' for dependency 'parking_lot'</li> <li>error: could not compile 'node-template' Caused by: process didn't exit successfully:</li> <li>error[E0432]: unresolved import 'rand_core::OsRng'</li> <li>error[E0433]: failed to resolve: use of undeclared crate or module <code>imp</code></li> </ul> <p>Explaining causes and remedies.</p>"},{"location":"frequent_errors/#error-duplicate-lang-item-in-crate","title":"error: duplicate lang item in crate","text":"<p>This error happens when we use different version crate but same crate on one crate. The error says the dependencies duplication so we can query the crate name as following.</p> <pre><code>$ cargo tree -e features -i {crate}\n</code></pre> <p>If we find the duplication of crate that we use same crate different version multiple times, we should align the version.</p>"},{"location":"frequent_errors/#error-the-wasm32-unknown-unknown-target-is-not-supported-by-default-you-may-need-to-enable-the-js-feature","title":"error: the wasm32-unknown-unknown target is not supported by default, you may need to enable the \"js\" feature","text":"<p>This error happens <code>getrandom</code> crate dependency on <code>std</code>. We need to disable <code>std</code> feature of <code>getrandom</code>.  </p> <p>Firstly, checking which libraries depend on <code>getrandom</code> depending on <code>std</code> to execute following command.</p> <pre><code>$ cargo tree -e features\n</code></pre> <p><code>cargo tree</code> command displays the dependencies tree. The libraries with <code>(*)</code> doesn't depend on <code>std</code> but if there is <code>getrandom</code> not marked as <code>(*)</code>, it would cause error.</p> <p>Secondly, independing from <code>std</code> library by followings.</p> <ul> <li>Add <code>default-features = false</code> to crate in <code>Cargo.toml</code> which is not marked as <code>(*)</code></li> <li>Add <code>#![cfg_attr(not(feature = \"std\"), no_std)]</code> if imported crate is made by self.</li> </ul> <p>And run <code>cargo tree</code> and check whether <code>getrandom</code> is marked as <code>(*)</code></p> <p>You can also use <code>cargo nono check</code> to check dependency on <code>std</code>.</p> <pre><code>$ cargo nono check\n</code></pre>"},{"location":"frequent_errors/#errore0603-module-group-is-private","title":"error[E0603]: module \"group\" is private","text":"<p>This error happens <code>syn</code> crate because its interface was change. We need to indicate exact version of <code>syn</code> as using expected behavior.</p> <pre><code>$ cargo update -p syn --precise 1.0.96\n</code></pre>"},{"location":"frequent_errors/#errore0512-cannot-transmute-between-types-of-different-sizes-or-dependently-sized-types","title":"error[E0512]: cannot transmute between types of different sizes, or dependently-sized types","text":"<p>This error happens on <code>runtime-interface</code> and both macro available when <code>#[cfg(all(not(feature = \"std\"), not(feature = \"disable_target_static_assertions\")))]</code> so we need to specify <code>std</code> as following.</p> <pre><code>[features]\ndefault = [\"std\"]\nstd = [\n\"crate/std\"\n]\n</code></pre>"},{"location":"frequent_errors/#errore0432-unresolved-import-sp_coreto_substrate_wasm_fn_return_value","title":"error[E0432]: unresolved import sp_core::to_substrate_wasm_fn_return_value","text":"<p>This error happens the crate which has <code>sp_api</code> dependency. And to clarify every crate which imported as <code>default-features = false</code> is described as <code>crate/std</code> in <code>[features]</code>.</p> <pre><code>[features]\ndefault = [\"std\"]\nstd = [\n\"crate/std\"\n]\n</code></pre>"},{"location":"frequent_errors/#error-failed-to-parse-manifest-at-failed-to-parse-the-version-requirement-011-for-dependency-parking_lot","title":"error: failed to parse manifest at failed to parse the version requirement '0.11 ' for dependency 'parking_lot'","text":"<p>This error happens the crate <code>parity-db</code> fails to find <code>parking_lot</code> version.</p> <pre><code>$ cargo update -p parity-db\n</code></pre>"},{"location":"frequent_errors/#error-could-not-compile-node-template-caused-by-process-didnt-exit-successfully","title":"error: could not compile 'node-template' Caused by: process didn't exit successfully:","text":"<p>This error happens because of nightly tool chain version difference. You need to select correct nightly tool chain version with following Polkadot release. https://github.com/paritytech/polkadot/releases</p>"},{"location":"frequent_errors/#errore0432-unresolved-import-rand_coreosrng","title":"error[E0432]: unresolved import 'rand_core::OsRng'","text":"<p>This error happens because there is no <code>OsRng</code> in <code>rand_core</code> root.</p> <pre><code>[dev-dependencies]\nrand_core = { version=\"0.6.4\", features = [\"getrandom\"] }\n</code></pre>"},{"location":"frequent_errors/#errore0433-failed-to-resolve-use-of-undeclared-crate-or-module-imp","title":"error[E0433]: failed to resolve: use of undeclared crate or module <code>imp</code>","text":"<p>This error happens when some crates depend on getrandom. We don't have exact answer for this error.</p> <p>Related issues</p> <p>(upgrade to 3.0) Target not supported: getrandom v0.2.2 Solana: Depending on Rand</p>"},{"location":"transaction_constraints/","title":"Transaction Constraints","text":"<p>In this section, we describe how to generate the proof for each transactions.</p>"},{"location":"transaction_constraints/#transfer","title":"Transfer","text":"<p>When we transfer the assets, as we described at Hide Transfer Amount section, at first we encrypt the value and the second we generate the proof which proves the validity of value. In terms of the transfer transactions, the constraints the transfer transactions need to satisfy are always same. We can modularize these constraints and generating the proof. The more details for the constraints, you can see it on Transaction Constraints section.</p>"},{"location":"transaction_constraints/#smart-contract-execution","title":"Smart Contract Execution","text":"<p>When we execute the smart contract, the constraints for each transaction is not the same so we can't use same with as in confidential transfer so we generate constraints for each opcode because the opcode operation is always same. We generate proof for each opcode which proves that the opcode was performed correctly and put these together to one proof. It's the same approach with <code>zkevm</code>. The <code>Substrate</code> works on <code>wasm</code> so we are going to implement <code>zkwasm</code>. We also describe the details constraints in Transaction Constraints section.</p>"},{"location":"transaction_constraints/#summarize","title":"Summarize","text":"<p>In terms of transfer, the contraints are always same so we can modularize these constraints. In terms of smart contract execution, the constraints are different for each smart contract so we customize the compiler and output the constraints when it compiles the smart contracts. The developer provides the constraints for users and they can know the constraints when they generate the proof.</p>"},{"location":"constraints/","title":"Transaction Constraints","text":"<p>In this section, we describe the concrete constraints for the transactions.</p> <ul> <li>Confidential Transfer</li> </ul>"},{"location":"constraints/#abstract","title":"Abstract","text":"<p>The transaction constraints consist of smaller pieces of constraints. There are three types of constraints we have as following.</p> Constraint Type Checking Condition Static or Dynamic Common Transaction Basic transactions object for example gas, signature and so on Static Confidential Transfer Confidential transfer condition Static Confidential Smart Contract Confidential smart contract condition Dynamic <p>The <code>Common Transaction</code> checks the basic transactions constraints and used for every transaction. When the users transfer assets, they need to generate the proof satisfying both <code>Common Transaction</code> and <code>Confidential Transfer</code> constraints. This consists of static constraints so the condition that the proof needs to satisfy are always same so we can modularize easily. However, when the users execute the smart contract, they need to generate the proof satisfying both <code>Common Transaction</code> and <code>Confidential Smart Contract</code> constraints. This consists of static and dynamic constraints so the condition that the proof needs to satisfy are always different.</p> <p>We would like to describe the constraints more detail and how we generate the proof for dynamic constraints.</p>"},{"location":"constraints/#process","title":"Process","text":"<p>Every transaction needs to be attached the proof which satisfies the constraints. The proof is generated by proving key according to <code>plonk</code> protocol. The blockchain needs to setup the parameters and the user needs to generate key pair as following.</p> Item Description x user private key y user public key srs setup parameters s randomness used for setup setup() setup function F field G elliptic curve group g elliptic curve generator d polynomial degree pk proving key vk verification key"},{"location":"constraints/#setup","title":"Setup","text":"<p>Setup the paramaters used for generate and verify proof.</p> <p>  setup(d, s) = [g, [s] g, [s^2] g, ... , [s^{d-1}] g] = (pk, vk)  </p>"},{"location":"constraints/#key-pair","title":"Key Pair","text":"<p>Generate the key pair for sign the transaction.</p> <p>  x \u2208 F   y = g^x  </p>"},{"location":"constraints/#common-transaction-constraints","title":"Common Transaction Constraints","text":"<p>Every transaction has common object items and this <code>Common Transaction Constraints</code> checks these condition. The transaction object items are following.</p> Item Description source transactor target destination address input transaction data value message value gasLimit gas limit of transaction gasPrice gas price of transaction nonce user account nonce <p>The <code>Common Transaction Constraints</code> checks that the value, gasLimit and gasPrice are valid. We use following function to generate proof and signature.</p> Function Description enc() ElGamal encryption sign() sign transaction with private key prove() proof generation"},{"location":"constraints/#encrypt-variables","title":"Encrypt Variables","text":"<p>First of all, the number should be encrypted by ElGamal.</p> <p>  enc(x, value, gasLimit, gasPrice, nonce) = value_{enc}, gasLimit_{enc}, gasPrice_{enc}, nonce_{enc}  </p>"},{"location":"constraints/#generate-proof-and-signature","title":"Generate Proof and Signature","text":"<p>Generate the proof with proving key and prove that this common params satisfy the statement.</p> <p>  \u03c0 = Prove(pk, statement_{common_constraint}[value_{enc}, gasLimit_{enc}, gasPrice_{enc}, nonce_{enc}])  </p> <p>Generate the signature with private key and prevent front-running attack.</p> <p>  \u03c3 = Sign(x, value_{enc}, gasLimit_{enc}, gasPrice_{enc}, nonce_{enc}, \u03c0)  </p>"},{"location":"constraints/#confidential-smart-contract","title":"Confidential Smart Contract","text":"<p>This <code>Confidential Transfer Constraints</code> checks that the users smart constract execution is valid. The condition that users proof needs to satisfy is different for each contracts so it's provided by Dapp owner as the same with that the Ethererum Dapp owner provides the ABI of smart contract. When the developers finish implementing the smart contract, the smart contract is compiled and output the Wasm binary and constraints metadata. The constraints metadata is the polynomials expressing the smart contract constraints. The users need the metadata, their secret key and <code>srs</code> when they generate the proof.</p>"},{"location":"constraints/confidential_transfer_constraints/","title":"Confidential Transfer Constraints","text":"<p>This <code>Confidential Transfer Constraints</code> checks whether users transfer transaction was done correctly.</p>"},{"location":"constraints/confidential_transfer_constraints/#transaction-requirement","title":"Transaction Requirement","text":"<p>Specifically, constraints check following conditions.</p> <ol> <li>The transfer amount is encrypted by exact sender and recipient public key</li> <li>The transfer amount and sender remaining balance are in valid range (not negative)</li> <li>The transfer amount and sender remaining balance are calculated correctly</li> </ol> <p>On the premise that every balances are encrypted by homomorphic encryption with different key and we need to perform addition and subtraction without revealing actual value. If Alice transfer Bob crypto currency, sender and recipient need to encrypt same transfer amount with their key in order to add and subtract their account without decrypt. First constraints are that they encrypt same transfer amount with their keys. And the next, we need to clarify that Alice has enough balance and her transfer amount is valid. Second constraints are that Alice balance is more than transfer amount and the transfer amount is not negative. The user needs to generate the proof which proves that the transaction satisfies above condition.</p>"},{"location":"constraints/confidential_transfer_constraints/#transfer-scheme","title":"Transfer Scheme","text":"<p>We describe the confidential transfer scheme here. We assume the case that Alice wants to transfer <code>t</code> amount crypto currency to Bob.</p> <p>We define the symbol for each parameters as following.</p> Symbol Description sk Alice private key pk Alice public key pk' Bob public key t Transfer amount b Alice remaining balance enc_bal_left Balance encrypted by Alice enc_bal_right Balance encrypted by Alice enc_left Transfer amount encrypted by Alice enc_right Transfer amount encrypted by Alice enc_t' Transfer amount encrypted by Bob r Randomness g Generator of elliptic curve point <p>We perform this transfer scheme on <code>jubjub</code> curve and the constraints are following.</p> <p> </p> <p>Users generate proof and attach it with transaction.</p>"},{"location":"constraints/confidential_transfer_constraints/#transaction-speed","title":"Transaction Speed","text":"<p>In my local PC, it takes about 5 seconds to generate proof and 78 milli-seconds to be verified.</p>"},{"location":"infrastructure/","title":"Infrastructure","text":"<p>Basically, all public blockchain state is public for everyone and it can be looked by unknown someone without any permission. To keep the privacy, the projects for example <code>Zcash</code> , <code>Monero</code> and so on realized the privacy preserving transfer. Now people can transfer crypto currency with private. However, the real world applications require more complicated functionalities and the blockchain should support various of use case. It was hard to realize the general purpose privacy preserving transactions but recent scaling and privacy technologies evolution allows us to make it practical.</p> <p>To achieve general purpose privacy preserving transactions, there are mainly five problems to be addressed. <code>Hide transfer amount</code>, <code>Gas limit</code>, <code>Zero knowledge scheme</code> and <code>Contract constraint</code>, <code>Attack protection</code>. Firstly, we would like to define <code>what is the privacy</code> and describe the solution. Finally, we would like to describe <code>the solution for the attack</code>.</p>"},{"location":"infrastructure/#contents","title":"Contents","text":"<p>The introduction contents are following.</p> <ol> <li>What is Privacy     We define what privacy is before we discuss the protocol.</li> <li>Hide Transfer Amount     We describe how to hide the transaction values.</li> <li>Gas Limit     We describe how to save the workload avoid to exceed the gas limit.</li> <li>Zero Knowledge Scheme     We compare the zero knowledge scheme and describe which is suitable for privacy preserving transactions.</li> <li>Transaction Constraints     We describe how user generates the transaction proof.</li> </ol> <p>These sections are work in progress and we are going to add the experiment result.</p>"},{"location":"infrastructure/gas_limit/","title":"Gas Limit","text":"<p>In this section, we describe the potential problem that privacy preserving transactions project have.</p>"},{"location":"infrastructure/gas_limit/#transaction-scheme","title":"Transaction Scheme","text":"<p>When we realize the privacy preserving transactions with homomorphic encryption, the transaction sender transaction scheme will first calculate the encrypted value and second generate the proof which proves the validity of these relationship. First schmeme needs to perform homomorphic arithmetic, and second one needs elliptic curve arithmetic and polynomial evaluations. And the verifier need to verify the proof by performing the pairing and homomorphic arithmetic. Both side needs to perform the heavy workload computation. The more computation we perform, the more gas cost we need to pay. If the verify function exceeds the gas limit, we would be unable to realize the protocol. To make it practical, we optimize the workload.</p>"},{"location":"infrastructure/gas_limit/#account-base-vs-utxo","title":"Account Base vs UTXO","text":"<p>When we generate the zero knowledge proof, the more complex data structure we need to prove the condition, the more computation we need. There are mainly two types of data blockchain structure. The <code>account base</code> is just key-value mapping data structure. It's easy to prove the condition. The <code>UTXO</code> uses the input and output transactions when it transfers the asset. It's complicated comparing with <code>account base</code>. However, the <code>UTXO</code> can prevent the double spending with data structure and it's hard to track the transaction history.</p>"},{"location":"infrastructure/gas_limit/#evm-vs-wasm","title":"EVM vs Wasm","text":"<p>When we verify the zero knowledge proof, the verify costs depend on efficiency of VM environment. If we perform the verify calculation efficiency, we would save the gas cost. When the Ethereum was launched, it's not designed for perform the zero knowledge functions so we have limitation of optimization once the blockchain is deployed. The Wasm is more efficient and we can customize and create new bytecodes. We have a lot of ways to optimize.</p>"},{"location":"infrastructure/gas_limit/#zero-knowledge-friendly","title":"Zero Knowledge Friendly","text":"<p>The data structure is the trade off between security and workload. We use the account base data structure because the gas limit is the main bottleneck. We are going to support Wasm because it's high performance and we can optimize the workload on blockchain. We don't have a plan to support EVM now so our blockchain doesn't have compatible with Ethereum contracts.</p>"},{"location":"infrastructure/hide_transfer_amount/","title":"Hide Transfer Amount","text":"<p>In this section, we describe how we hide the transfer amount.</p>"},{"location":"infrastructure/hide_transfer_amount/#homomorphic-encryption-vs-commitment","title":"Homomorphic Encryption vs Commitment","text":"<p>We have two options to hide the transfer amount homomorphic encryption and commitment. The homomorphic encryption allows us to calculate the encrypted number. To combine the homomorphic encryption and zero knowledge proof, we can calculate the encrypted number without decrypting and check whether the calculation was done correctly by zero knowledge proof. And the other option is commitment. The commitment uses the one-way function for example hash function. It hides the original value. The user provides the part of original value and check whether original value satisfies the condition. We describe the famous commitment in Pedersen Commitment section.</p> <p>If we use the commitment scheme, we need to generate the randomness for each transaction and prove the validity with it. It's hard for users to deal every randomness and also we support the contract execution so it's not practical to generate randomness for each value. If we use the homomorphic encryption, we can realize it simpler way. We are going to describe how we hide the transfer amount and prove whether that value satisfies the condition in Transaction Constraints section.</p>"},{"location":"infrastructure/hide_transfer_amount/#scheme","title":"Scheme","text":"<p>To summarize the two scheme difference, it would be following.</p>"},{"location":"infrastructure/hide_transfer_amount/#homomorphic-encryption","title":"Homomorphic Encryption","text":"<p>The homomorphic encryption can calculate the encrypted number. Let <code>Enc()</code> encrypt function and we can't know the input from output. We can get calculation result without revealing actual value.</p> <p> </p> <p>The encrypted value doesn't expose any information so we need to attach the proof which proves the value satisfies the condition. If users try to transfer the asset, user need to prove that the user balance is more than transfer amount, transfer amout is not negative and so on.</p>"},{"location":"infrastructure/hide_transfer_amount/#commitment","title":"Commitment","text":"<p>The commitment can hide the number and prove that the value satisfies the condition. Let <code>Hash()</code> hash function. To make it hard to know the input from output, we generate the randomness. The hash function takes <code>amount</code> and <code>randomness</code> as argument. If user wants to send <code>3</code> asset and it's balance is <code>10</code>, user would generate the randomness and prove that following equation holds.</p> <p>  Hash(3, 100) + Hash(7, 200) - Hash(10, 300) = 0  </p> <p>The transfer amount user wants send and the amount after transfer is equal to current balance when it's added. The hashed value is called commitment. We describe this more detail with example in Pedersen Commitment section.</p>"},{"location":"infrastructure/what_is_privacy/","title":"What is Privacy","text":"<p>Before we describe our protocol, we would like to define what the <code>privacy</code> exactly means.</p>"},{"location":"infrastructure/what_is_privacy/#confidential-vs-anonymous","title":"Confidential vs Anonymous","text":"<p>There are two types of privacy level <code>confidential</code> and <code>anonymous</code>. The difference between them is that how much information we hide. The <code>confidential</code> means it hides the input and output. The <code>anonymous</code> means it hide the users related the transaction.</p>"},{"location":"infrastructure/what_is_privacy/#transfer-example","title":"Transfer Example","text":"<p>If the protocol supports <code>confidential</code>, the users would be able to hide the input and output. When users send the transaction, the input and output are going to be <code>balance</code>, <code>transfer amount</code> and <code>after balance</code>. The function needs to know that the transfer satisfies the conditions for example, the amount is not negative, the balance is more than transfer amount and so on. The <code>confidential</code> transactions can verify these conditions without revealing input and ouput values. We use the homomorphic encryption to realize this feature. You can see it on <code>Hide Transfer Amount</code> section.</p> <p>If the protocol supports <code>anonymous</code>, the users would be able to hide the users information related to transactions in addition to <code>confidential</code>. When users transfer the assets, the users information related to transactions are going to be <code>sender</code> and <code>recipient</code>. There are some ways to hide users information and we describe some of them in related tools. The typical tool to hide the <code>sender</code> is the <code>Ring Signature</code> and the <code>recipient</code> is the Stealth Address.</p>"},{"location":"infrastructure/what_is_privacy/#summarize","title":"Summarize","text":"<p>To summarize the story, the <code>confidential</code> hides the transaction contents and the <code>anonymous</code> hides the transaction senders and recipients. We describe the contents and privacy level in table.</p> Item Confidential Anonymous Balance \u2705 \u2705 Transfer Amount \u2705 \u2705 Sender - \u2705 Recipient - \u2705"},{"location":"infrastructure/zero_knowledge_scheme/","title":"Zero Knowledge Scheme","text":"<p>In this section, we describe the zero knowledge scheme features.</p>"},{"location":"infrastructure/zero_knowledge_scheme/#snarks-vs-starks-vs-bulletproofs","title":"<code>SNARKs</code> vs <code>STARKs</code> vs <code>Bulletproofs</code>","text":"<p>We compare the three types of zero knowledge scheme <code>zk-SNARKs</code>, <code>zk-STARKs</code> and <code>Bulletproofs</code>. The <code>zk-SNARKs</code> is the most efficient. We can verify the proof with const or almost const time and generate proof process is also efficient. The proof size is also small. However, it's necessary to setup the parameters. We can save a lot of workload because of this but it would be the critical security issue. The <code>zk-STARKs</code> doesn't need to setup parameters and it has quantum tolerance. However, its proof size is far bigger than <code>zk-SNARKs</code> and the workload of verification process also far bigger than <code>zk-SNARKs</code>. The <code>Bulletproofs</code> doesn't need to setup parameters and its feature is in the middle between <code>zk-SNARKs</code> and <code>zk-STARKs</code> but it doesn't have quantum tolerance.</p>"},{"location":"infrastructure/zero_knowledge_scheme/#summarize","title":"Summarize","text":"<p>To summerize the above comparison, it would be as following table.</p> Scheme Trusted Setup Prover Cost Verifier Cost Proof Size Quantum Tolerance zk-SNARKs Necessary Low Low Small No zk-STARKs Unnecessary Moderate High Large Yes Bulletproofs Unnecessary Low Moderate Moderate No"},{"location":"infrastructure/zero_knowledge_scheme/#privacy-preserving-transactions-friendly","title":"Privacy Preserving Transactions Friendly","text":"<p>The <code>Bulletproofs</code> is mainly used for other privacy preserving transactions project for example <code>Aztec</code>, <code>Zether</code> and so on. That's because these projects are Ethereum smart contract base projects so if they use the <code>zk-SNARKs</code>, it's necessary to setup the parameters for each deploy smart contracts. It's really hard to collect enough parties to setup the parameters for each deploy. We use the <code>zk-SNARKs</code> because of its efficiency and the <code>plonk</code> allows us to setup parameters without depending on circuit. In other words, once we setup the parameters, we can reuse them when we prove the transactions.\u3000</p>"},{"location":"technical/","title":"Abstract","text":"<p>In this section, we would like to explain about the cryptgraphic scheme used for other privacy project.</p>"},{"location":"technical/#stealth-address","title":"Stealth Address","text":"<p>The <code>Stealth Address</code> hides the recipient address by creating one time address. Shortly, creating one time address from public key and recovering that private key with using <code>Diffie-Hellman</code> key exchange, users can hide who exactly receives the assets. The <code>Monero</code> uses this technology.</p>"},{"location":"technical/#pedersen-commitment","title":"Pedersen Commitment","text":"<p>The <code>Pedersen Commitment</code> hides the transfer amount by commitment scheme. Shortly, using zero testing and generating blind factors, users can prove the amount validity without revealing actual amount. The <code>Monero</code> uses this technology.</p>"},{"location":"technical/#non-interactive-zero-knowledge-proof","title":"Non Interactive Zero Knowledge Proof","text":"<p>The <code>Non Interactive Zero Knowledge Proof</code> proves the computation validity without revealing information about the value used with computation. In this section, we describe the <code>zk-SNARKs</code>. The <code>Zcash</code> uses this technology. Shortly, the QAP converts computation into polynomials, the Polynomial Commitment proves the validity of polynomials and the Homomorphic Encryption evaluates the polynomials without revealing raw coefficients.</p>"},{"location":"technical/homomorphic_encryption/","title":"Homomorphic Encryption","text":"<p>In previous two sections, we enable to check whether <code>computation</code> was done correctly through polynomials equation and these polynomials are generated with valid process with following equations.</p> <ul> <li> <p>QAP </p> </li> <li> <p>Polynomial Commitment  L(x) + R(x) * X^{d+1} + O(x) * X^{2d+1} = F(x)   F(x) = k_0 + k_1X + k_2X^2 + ... + k_{3d}X^{3d}   (\\acute a_0,...,\\acute a_{3d}, \\acute b_0,...,\\acute b_{3d}) = (a_0 * k_0,...,a_{3d} * k_{3d}, b_0 * k_0,...,b_{3d} * k_{3d})   (\\acute a_0,...,\\acute a_{3d}) = \u03b1(\\acute b_0,...,\\acute b_{3d})  </p> </li> </ul> <p>Lastly, we would like to send these information with zero knowledge. To do so, we are going to use <code>Homomorphic Encryption</code>.</p>"},{"location":"technical/homomorphic_encryption/#abstract","title":"Abstract","text":"<p>The <code>Homomorphic Encryption</code> achieves above equations evaluation without revealing any information. The difference between homomorphic encryption and normal encryption is that the <code>Homomorphic Encryption</code> can do add, sub and mul remaining encrypted. With this, the verifier doesn't know any information about these polynomials but able to check the relation between them.</p>"},{"location":"technical/homomorphic_encryption/#details","title":"Details","text":"<p>Specifically, if the encryption supports <code>additive</code> and <code>multiplicative</code>, we would call it <code>Full Homomorphic Encryption</code> but it takes so much cost to calculate or ciphertext is too big to transfer through the internet. In this case, we deal the encryption which supports multiple additive and one time multiplicative. We realize these with <code>elliptic curve</code> and <code>pairing</code>.</p>"},{"location":"technical/homomorphic_encryption/#elliptic-curve","title":"Elliptic Curve","text":"<p>The <code>elliptic curve</code> is the equation look like following.</p> <p>  y^2 = x^3 + ax + b  </p>"},{"location":"technical/homomorphic_encryption/#pairing","title":"Pairing","text":"<p>The <code>pairing</code> is the mapping which takes two elliptic curve points and map to the element of finitie field as following.</p> <p>  f: G * G -&gt; F_p  </p> <p>There are some types of pairing functions but it's complicated so describing the relationship with simple model. Let's denote the two generators of elliptic as <code>G1</code>, <code>G2</code> and, each scalar as <code>a</code>, <code>b</code> and generator of finite field as <code>g</code>. We can express the relactionship between these two elliptic curve points and finite field element as following.</p> <p>  f: aG1 * bG2 -&gt; g^{ab}  </p>"},{"location":"technical/non_interactive_zero_knowlege_proof/","title":"Non Interactive Zero Knowledge Proof","text":"<p>The <code>Non Interactive Zero Knowledge Proof</code> referred as to <code>NIZK</code> prove the statement without revealing any information about the statement. There are some types of <code>NIZK</code> for example <code>SNORKs</code>, <code>STARKs</code> and so on. In this section, we describe the <code>SNARKs</code> and especially <code>Pinocchio Protocol</code>. It's a little bit complicated technology so I divide into three parts.</p>"},{"location":"technical/non_interactive_zero_knowlege_proof/#abstract","title":"Abstract","text":"<p>The <code>SNARKs</code> converts the computation problems into the polynomial equations. We can not only hide the computation itself but also verify the computation faster than compute it again. That's why the <code>SNARKs</code> is also used for scaling solution for example <code>zk rollup</code>.</p>"},{"location":"technical/non_interactive_zero_knowlege_proof/#detail","title":"Detail","text":"<p>The <code>SNARKs</code> has three steps.</p> <ol> <li>QAP</li> </ol> <p>Converting computation which we want to prove without revealing additional information into polynomial equations. In <code>Pinocchio Protocol</code>, we need to generate polynonial equations for each computation. The polynomial equations are decided for corresponding computation.</p> <ol> <li>Polynomail Commitment</li> </ol> <p>Hiding the secret as polynomial coefficients, opening with evaluating that polynomials at point, and we can prove the computation was done correctly.</p> <ol> <li>Homomorphic Encryption</li> </ol> <p>The polynomial coefficients are encrypted to keep the secret so we need perform evaluation with remaining encrypted. The <code>Homomorphic Encryption</code> can perform the multiple time addition and one time multiplication for encrypted number using elliptic curve and pairing.</p>"},{"location":"technical/pedersen_commitment/","title":"Pedersen Commitment","text":""},{"location":"technical/pedersen_commitment/#abstract","title":"Abstract","text":"<p>The <code>Pedersen Commitment</code> is the technology which allows us to check the transfer amount is valid without revealing actual amount.</p>"},{"location":"technical/pedersen_commitment/#details","title":"Details","text":"<p>This technology uses additivity of elliptic curve. Hiding the transfer amount as scalar of elliptic curve point and mixing random value refer as to <code>blinding factor</code>. Let's take a look the squence.</p> <ol> <li>Setup the parameters</li> <li>Hide the transfer amount</li> <li>Verify the transfer amount</li> </ol> <p>Above sequence used for confidential transfer to keep the transfer amount secret.</p>"},{"location":"technical/pedersen_commitment/#setup-the-parameters","title":"Setup The Parameters","text":"<p>First of all, we'd like to setup the parameters we are going to use with the <code>Pedersen Commitment</code>. Selecting generator <code>G</code> over prime order elliptic curve group and randomness <code>a</code> less than order prime. Calculating <code>H = aG</code> and making <code>H</code> and <code>G</code> public. We can't predict the <code>a</code> value from <code>H</code> and <code>G</code> because of discrete logarithm.</p> Variable Explanation Derivation p prime number - a random number a \u2208 Fp C(x) elliptic curve function - G generator of elliptic curve point G \u2208 C(Fp) H generator made by random a H = aG"},{"location":"technical/pedersen_commitment/#hide-the-transfer-amount","title":"Hide The Transfer Amount","text":"<p>Let's assume that Alice has <code>10</code> balance and send Bob to <code>3</code>. We need to check <code>{Alice balance} - {transfer amount} = {Alice after balance}</code> without revealing any information about Alice balance. Alice knows <code>H</code>, <code>G</code> and her balance so she computes following value.</p> <ul> <li>Alice balance commitment  </li> <li>Transfer amount commitment  C(3) = 3H + x_2G  </li> <li>Alice after balance commitment  C(10 - 3) = 7H + x_3G  </li> </ul> <p>In above equation, <code>x_1 ~ x_3</code> are called <code>blinding factor</code> and each blinding factor need to be set to hold <code>{Alice balance} - {transfer amount} = {Alice after balance}</code> equation. Let's say <code>x_1 = 330</code>, <code>x_2 = 30</code> and <code>x_3 = 300</code>.</p>"},{"location":"technical/pedersen_commitment/#verify-the-transfer-amount","title":"Verify The Transfer Amount","text":"<p>In previous section, Alice computes the following commitment.</p> <p>  C(10, 330) = 10H + 330G   C(3, 30) = 3H + 30G   C(10 - 3, 300) = 7H + 300G  </p> <p>Let's check if Alice transfer amount is valid. The elliptic curve arithmetic supports additive so we can check <code>{Alice balance} - {transfer amount} = {Alice after balance}</code> as following.</p> <p>  C(10, 330) - C(3, 30) - C(10 - 3, 300) = C(10 - 3 - 7, 330 - 30 - 300) = 0H + 0G = 0  </p> <p>If above equation holds up, we can know the transfer amount is valid. Through this process, <code>balance</code> and <code>transfer amount</code> are encrypted by elliptic curve so no one can predict actual value from public information. This is how we conceal the transfer transaction and verify the validity.</p>"},{"location":"technical/polynomial_commitment/","title":"Polynomial Commitment","text":"<p>In previous section, we enable to check whether <code>computation</code> was done correctly by the knowledge of polynomial which can be devided by minimal polynomial <code>Z(x)</code> as following.</p> <p> </p> <p>However, we can create equation easily because <code>Z(x)</code> is public information. Then we need to verify whether <code>L(x), R(x), O(x)</code> are created by using valid input. To do so, we are going to use <code>Polynomial Commitment</code>.</p>"},{"location":"technical/polynomial_commitment/#abstract","title":"Abstract","text":"<p>The <code>Polynomial Commitment</code> check whether the prover know polynomials <code>L(x), R(x), O(x)</code> and these comes from valid input.</p>"},{"location":"technical/polynomial_commitment/#details","title":"Details","text":"<p>To know polynomials <code>L(x), R(x), O(x)</code> means having knowledge of coefficients of them.</p>"},{"location":"technical/polynomial_commitment/#combination","title":"Combination","text":"<p>First of all, we combine these polynomials to one in order to make check process easier. Let's say degree of polynomials <code>L(x), R(x), O(x)</code> as <code>d</code>, we can combine them into one as following and let combined polynomial as <code>F(x)</code>.</p> <p>  L(x) + R(x) * X^{d+1} + O(x) * X^{2d+1} = F(x)  </p> <p>In polynomial <code>F(x)</code>, the coefficients of <code>0~d</code> degree expresses <code>L(x)</code> coefficients, <code>d+1~2d</code> is <code>R(x)</code> and <code>2d+1~3d</code> is <code>O(x)</code> as well. The polynomial <code>F(x)</code> degree is <code>3d</code> and when we denote coefficients as k, it would be following.</p> <p>  F(x) = k_0 + k_1X + k_2X^2 + ... + k_{3d}X^{3d}  </p>"},{"location":"technical/polynomial_commitment/#verification","title":"Verification","text":"<p>The verification processes are following.</p> <ol> <li>Bob choses random <code>\u03b1, (a_0,...,a_{3d}) \u2208 F</code> and compute <code>(b_0,...,b_{3d}) = \u03b1(a_0,...,a_{3d})</code>.</li> <li>Bob sends Alice to <code>(a_0,...,a_{3d})</code> and <code>(b_0,...,b_{3d})</code>.</li> <li>Alice computes following.  (\\acute a_0,...,\\acute a_{3d}, \\acute b_0,...,\\acute b_{3d}) = (a_0 * k_0,...,a_{3d} * k_{3d}, b_0 * k_0,...,b_{3d} * k_{3d})  </li> <li>Bob checks following.  (\\acute a_0,...,\\acute a_{3d}) = \u03b1(\\acute b_0,...,\\acute b_{3d})  </li> </ol> <p>If Alice don't know the coefficients, she couldn't do step <code>3</code>. With using this step, we can know that the prover know polynomials <code>L(x), R(x), O(x)</code> and these comes from valid input.</p>"},{"location":"technical/polynomial_commitment/#next","title":"Next","text":"<p>In this section, we understood how to check the prover polynomials comming from valid input but these information would be known by verifier. To hide these information from verifier, we are using homomorphic encryption.</p>"},{"location":"technical/qap/","title":"QAP (Quadratic Arithmetic Programs)","text":""},{"location":"technical/qap/#abstract","title":"Abstract","text":"<p>The <code>QAP</code> is the technology which converts <code>computation</code> to <code>polynomial groups</code>. With this, we can check whether the <code>computation</code> was executed correctly just factor the polynomial without execute <code>computation</code> again.</p>"},{"location":"technical/qap/#details","title":"Details","text":"<p>Let's take a look at details. I give a example. Let's prove that following computation was executed correctly.</p> <p> </p> <p>Assume that <code>c</code> is public input. <code>a</code> and <code>b</code> are private input. Prove that knowledge of <code>a</code> and <code>b</code> satisfying above equation.</p>"},{"location":"technical/qap/#flattening","title":"Flattening","text":"<p>First of all, let's disassemble the <code>computation</code> to minimum form using multicative.</p> <p>  1: a * a = a^2   2: b * b = b^2   3: a^2 * b^2 = c  </p> <p>Now the computation was disassembled to three gate.</p>"},{"location":"technical/qap/#r1cs","title":"R1Cs","text":"<p>As described, we have three multicative computation and want to check whether each steps are executed correctly to set constraint. Before that, we permute above characters as following.</p> <p>  [a, a^2, b, b^2, c] -&gt; [v, w, x, y, z]  </p> <p>And now, our computation can be expressed as following table. Left, Right and Output.</p> Gate L R O 1 v v w 2 x x y 3 y w z"},{"location":"technical/qap/#qap","title":"QAP","text":"<p>Let's express above table as polynomail groups. As example, express <code>v</code> polynomial on <code>L</code> column. <code>x</code> cordinate is <code>Gate</code> number and <code>y</code> cordinate is if that variable is used, it's going to be 1 and oserwise 0. In <code>L</code> column, <code>v</code> is only used <code>Gate</code> 1 so express as <code>(1, 1) (2, 0) (3, 0)</code>. Find polynomial using <code>Lagrange interpolation formula</code> for each variables.</p> <p>L column polynomial</p> Variable Cordinate Polynomial Name v (1, 1) (2, 0) (3, 0)  \\frac{x^2}{2} - \\frac{5x}{2} + 3 \\\\  Lv w (1, 0) (2, 0) (3, 0) 0 Lw x (1, 0) (2, 1) (3, 0)  -x^2 + 4x - 3  Lx y (1, 0) (2, 0) (3, 1)  \\frac{x^2}{2} - \\frac{3x}{2} + 1 \\\\  Ly z (1, 0) (2, 0) (3, 0) 0 Lz <p>Above polynomial expresses the gate that variable uses. When we pass gate number to polynomial <code>v</code>  \\frac{x^2}{2} - \\frac{5x}{2} + 3 \\\\ , we can know which gate the <code>v</code> is used. For example, we pass <code>1</code> to polynomial <code>v</code>, it returns <code>1</code> so the variable <code>v</code> is used on gate <code>1</code> but it returns <code>0</code> when we pass <code>2</code> and <code>3</code> so it's not used on these gate. When we add all polynomial <code>Lv + Lw + Lx + Ly + Lz = L(x)</code>, it returns <code>1</code> when we pass <code>1</code>, <code>2</code> and <code>3</code>. We do the same operation for each column and get polynomials as well.</p> <ul> <li>L(x) <code>Lv + Lw + Lx + Ly + Lz</code> </li> <li>R(x) <code>Rv + Rw + Rx + Ry + Rz</code> </li> <li>O(x) <code>Ov + Ow + Ox + Oy + Oz</code> </li> </ul> <p>We can intruduce above polynomials when we decide the <code>computation</code>.</p>"},{"location":"technical/qap/#proof","title":"Proof","text":"<p>From now on, we are going to prove the state ment. In here, we use <code>a = 2</code>, <code>b = 3</code> and <code>c = 36</code>. We can get actual value as following.</p> <p>  [v, w, x, y, z] -&gt; [2, 4, 3, 9, 36]  </p> <p>And we multiply above variables by for each polynomial. For example, <code>L(x)</code> is following.</p> <p>  L(x) = v * Lv + w * Lw + x * Lx + y * Ly + z * Lz  </p> <p>When we pass the <code>1</code> to <code>L(x)</code>, we can get <code>v</code> because only <code>Lv</code> returns <code>1</code> and others return <code>0</code>. <code>R(x)</code> as well and <code>O(x)</code> returns <code>w</code> so following equation holds.</p> <p>  L(1) * R(1) - O(1) = v * v - w = 2 * 2 - 4 = 0  </p> <p>It corresponds the table we saw in <code>R1Cs</code> and above also holds the case <code>x = 2</code> and <code>x = 3</code>. When we want to prove the statement, we are going to make above polynomial with secret <code>[v, w, x, y, z] -&gt; [2, 4, 3, 9, 36]</code> so polynomial would be integrated as one as following.</p> <p>  L(x) = 2 * Lv + 4 * Lw + 3 * Lx + 9 * Ly + 36 * Lz   R(x) = 2 * Rv + 4 * Rw + 3 * Rx + 9 * Ry + 36 * Rz   O(x) = 2 * Ov + 4 * Ow + 3 * Ox + 9 * Oy + 36 * Oz   L(x) * R(x) - O(x) = P(x)  </p> <p>We make the <code>P(x)</code> to prove the statement.</p>"},{"location":"technical/qap/#verification","title":"Verification","text":"<p>We can know whether <code>computation</code> was executed correctly to devide <code>P(x)</code> with <code>(x - 1) * (x - 2) * (x - 3)</code>. If it's devided as following prover knows the secret <code>a</code> and <code>b</code> leading <code>c</code>.</p> <p>  P(x) = (x - 1) * (x - 2) * (x - 3) * T(x)  </p>"},{"location":"technical/qap/#next","title":"Next","text":"<p>In this section, we understood how to convert <code>computation</code> to <code>polynomial groups</code> but there are some possibility that <code>P(x)</code> was made without using secret. In addition to this, we can know the secret to factor the polynomial. Zk SNARKs addresses the former problem with <code>Polynomial Commitment</code> and latter problem with <code>homomorphic encryption</code>.</p>"},{"location":"technical/reddsa_signature/","title":"RedDSA Signature","text":"<p>RedDSA is a Schnorr-based signature scheme, optionally supporting key re-randomization.</p>"},{"location":"technical/reddsa_signature/#re-randomization","title":"Re-Randomization","text":"<p>We can generate one-time secret related to wallet private key and use it for performing some operation of transactions. After some operation, we can prove that the secret is related to private key and the operation was done correctly. In Zash Sapling, it's used for transaction auditability and proof delegation.</p>"},{"location":"technical/reddsa_signature/#library","title":"Library","text":"<p>RedDSA is digital signature algorithm as the same with ECDSA and EdDSA. When we use jubjub curve on RedDSA, it's called redjubjub. It's actual scheme as the same with secp256k1 and ed25519. We have redjubjub implementation here.</p>"},{"location":"technical/reddsa_signature/#reference","title":"Reference","text":"<p>Zcash Protocol Specification, Version 2022.3.8</p>"},{"location":"technical/stealth_address/","title":"Stealth Address","text":""},{"location":"technical/stealth_address/#abstract","title":"Abstract","text":"<p>The <code>Stealth Address</code> is the technology which allows us to hide the recipient address.</p>"},{"location":"technical/stealth_address/#details","title":"Details","text":"<p>The blockchain for example <code>Ethereum</code>, we generate the private key and the public key based on private key. The hash of the public key is going to be a address which specifies the recipient. This address corresponds one private key and public key pair so we can easily identify who is the recipient of the transaction. In our blockchain, we generate recipient address for each transactions and make it hard to identify the recipient.</p> <ol> <li>Generates recipient public key pairs</li> <li>Generates recipient <code>Stealth Address</code></li> <li>Prove the ownership of <code>Stealth Address</code></li> </ol> <p>Above sequence used for confidential transfer to keep the recipient address anonymous.</p>"},{"location":"technical/stealth_address/#generates-recipient-public-key-pairs","title":"Generates Recipient Public Key Pairs","text":"<p>Every transaction has recipient and we hide the recipient with stealth address. We assume Alice send transaction to Bod.</p> <p>First of all, Bod generates the two key pairs (a, A) and (b, B) such that <code>aG = A</code> and <code>bG = B</code>. <code>a</code> and <code>b</code> are the private keys and, <code>A</code> and <code>B</code> are the public keys.</p> Variable Explanation Derivation a Bob private key a \u2208 Fp b Bob private key b \u2208 Fp A Bob public key for <code>a</code> a * G B Bob public key for <code>b</code> b * G"},{"location":"technical/stealth_address/#generates-recipient-stealth-address","title":"Generates Recipient <code>Stealth Address</code>","text":"<p>Secondly, Alice generates the Bob recipient address as referred to the <code>Stealth Address</code>. Alice selects the random number <code>r</code> and calculate the <code>Stealth Address</code> with Bob public keys such that following.</p> <p> </p> <p>No one can link P address with <code>A</code> and <code>B</code> because it's concealed by elliptic curve arithmetic. Alice publish the <code>P</code> and <code>R</code> calculated as <code>R = rG</code>.</p> Variable Explanation Derivation r randomness generated by Alice r \u2208 Fp H one-way hash function which takes curve point and maps field element e: xG -&gt; Fp R public value generated by Alice r * G P stealth address of Bob H(r*A) * G + B"},{"location":"technical/stealth_address/#prove-the-ownership-of-stealth-address","title":"Prove the ownership of <code>Stealth Address</code>","text":"<p>Lastly, Bob needs to prove the ownership of <code>Stealth Address</code> to use assets associated with it. Bob knows his private keys <code>a</code> and <code>b</code>. He can calculate the private key of <code>P</code> with <code>x = H(a * R) + b</code>. This is the <code>Diffie\u2013Hellman key exchange</code> algorithm. Only Bob can know the <code>x</code>. This is how concealing the recipient address. Next section, we explain how we conceal the amount of transactions.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>In this section, we describe how to use the pallet for privacy-preserving transactions.</p> <ul> <li>pallet-plonk</li> <li>pallet-encrypted-balance</li> <li>confidential_transfer</li> </ul> <p>You can check Frequent Errors when the error happens.</p>"},{"location":"tutorial/#abstract","title":"Abstract","text":"<p>The privacy-preserving transactions consists of several pallet components. We roughly explain what kind of role for each pallet has.</p>"},{"location":"tutorial/#pallet-plonk","title":"pallet-plonk","text":"<p><code>plonk</code> is a zk-Snarks scheme and allows us to prove that the computation was done correctly. We perform transaction on <code>off-chain</code> and generate the proof. The blockchain verifies the proof and approve the transaction. We define the constraints circuit for <code>confidential transfers</code> and <code>confidential smart contracts</code> by this pallet.</p>"},{"location":"tutorial/#pallet-encrypted-balance","title":"pallet-encrypted-balance","text":"<p>Users balances are encrypted by default. We use additive homomorphic arithmetic to hide the integer in transaction. Combining original pallet-balance and <code>ElGamal</code> encryption and we implemented pallet-encrypted-balance. This pallet can't be used only by this self, because this doesn't check the validity of additive homomorphic arithmetic.</p>"},{"location":"tutorial/#confidential_transfer","title":"confidential_transfer","text":"<p>Users can transfer without being known actual amount by others with this pallet. <code>plonk</code> checks the <code>confidential transfer constraints</code> and pallet-encrypted-balance performs the additive homomorphic state transition.</p>"},{"location":"tutorial/confidential_transfer_pallet/","title":"Confidential Transfer Tutorial","text":"<p>In this tutorial, we are going to generate test data and test its functionalities. We assume that you already unserstand what Confidential Transfer is.</p> <p>The steps are following.</p> <ol> <li>Define the <code>confidential_transfer</code> as depencencies</li> <li>Generate test data used for <code>confidential_transfer</code></li> <li>Test funcitonalities</li> </ol>"},{"location":"tutorial/confidential_transfer_pallet/#1-define-the-confidential_transfer-as-depencencies","title":"1. Define the confidential_transfer as depencencies","text":"<p>First of all, you need to define the <code>confidential_transfer</code>.</p> <ul> <li>/Cargo.toml <pre><code>confidential_transfer = { git = \"https://github.com/KogarashiNetwork/Kogarashi\", branch = \"master\", default-features = false }\npallet_encrypted_balance = { git = \"https://github.com/KogarashiNetwork/Kogarashi\", branch = \"master\", default-features = false }\npallet_plonk = { git = \"https://github.com/KogarashiNetwork/Kogarashi\", branch = \"master\", default-features = false }\nshe_elgamal = { git = \"https://github.com/KogarashiNetwork/Kogarashi\", branch = \"master\", default-features = false }\nbls_12_381 = { git = \"https://github.com/KogarashiNetwork/Kogarashi\", branch = \"master\", default-features = false }\nrand_core = {version=\"0.6\", default-features = false }\n</code></pre> <p>The <code>confidential_transfer</code> depends on <code>rand_core</code> so please import it.</p>"},{"location":"tutorial/confidential_transfer_pallet/#2-generate-test-data-used-for-confidential_transfer","title":"2. Generate test data used for <code>confidential_transfer</code>","text":"<p>Secondly, we would like like to setup the Alice and Bob account on testing runtime. Define the <code>new_test_ext</code> for genesis config and reflect the testing data for runtime storage.</p> <pre><code>fn new_test_ext(\nalice_address: u64,\nalice_private_key: Fp,\nalice_balance: u32,\nalice_radomness: Fp,\nbob_private_key: Fp,\nbob_address: u64,\nbob_balance: u32,\nbob_radomness: Fp,\n) -&gt; sp_io::TestExternalities {\nlet alice_balance = EncryptedNumber::encrypt(alice_private_key, alice_balance, alice_radomness);\nlet bob_balance = EncryptedNumber::encrypt(bob_private_key, bob_balance, bob_radomness);\n\nlet mut t = frame_system::GenesisConfig::default()\n.build_storage::&lt;TestRuntime&gt;()\n.unwrap();\npallet_encrypted_balance::GenesisConfig::&lt;TestRuntime&gt; {\nbalances: vec![(alice_address, alice_balance), (bob_address, bob_balance)],\n}\n.assimilate_storage(&amp;mut t)\n.unwrap();\n\nlet mut ext = sp_io::TestExternalities::new(t);\next.execute_with(|| System::set_block_number(1));\next\n}\n</code></pre> <p>Thirdly, we define <code>generate_default_test_data</code> to generate parameters used for <code>confidential_transfer</code>.</p> <pre><code>fn generate_default_test_data() -&gt; (u64, Fp, u16, Fp, Fp, u64, u16, Fp, u16, u16, u16) {\nlet mut rng = rand::thread_rng();\n\nlet alice_address = rng.gen::&lt;u64&gt;();\nlet alice_private_key = Fp::random(OsRng);\nlet alice_balance = rng.gen::&lt;u16&gt;();\nlet alice_radomness = Fp::random(OsRng);\nlet bob_private_key = Fp::random(OsRng);\nlet bob_address = rng.gen::&lt;u64&gt;();\nlet bob_balance = rng.gen::&lt;u16&gt;();\nlet bob_radomness = Fp::random(OsRng);\nlet transfer_amount = rng.gen_range(0..alice_balance);\nlet alice_after_balance = alice_balance - transfer_amount;\nlet bob_after_balance = bob_balance + transfer_amount;\n\n(\nalice_address,\nalice_private_key,\nalice_balance,\nalice_radomness,\nbob_private_key,\nbob_address,\nbob_balance,\nbob_radomness,\ntransfer_amount,\nalice_after_balance,\nbob_after_balance,\n)\n}\n</code></pre>"},{"location":"tutorial/confidential_transfer_pallet/#3-test-funcitonalities","title":"3. Test funcitonalities","text":"<p>Finally, we combine previous sections together and test functionalities.</p> <pre><code>fn main() {\nlet k = 14;\nlet label = b\"verify\";\nlet mut rng = get_rng();\nlet (\nalice_address,\nalice_private_key,\nalice_balance,\nalice_radomness,\nbob_private_key,\nbob_address,\nbob_balance,\nbob_radomness,\ntransfer_amount,\nalice_after_balance,\nbob_after_balance,\ntransfer_randomness,\n) = generate_default_test_data();\nnew_test_ext(\nalice_address,\nalice_private_key,\nalice_balance,\nalice_radomness,\nbob_private_key,\nbob_address,\nbob_balance,\nbob_radomness,\n)\n.execute_with(|| {\n// default balance decryption check\nlet alice_encrypted_balance = ConfidentialTransfer::total_balance(&amp;alice_address);\nlet alice_raw_balance = alice_encrypted_balance.decrypt(alice_private_key);\nlet bob_encrypted_balance = ConfidentialTransfer::total_balance(&amp;bob_address);\nlet bob_raw_balance = bob_encrypted_balance.decrypt(bob_private_key);\n\nassert_eq!(alice_raw_balance.unwrap() as u16, alice_balance);\nassert_eq!(bob_raw_balance.unwrap() as u16, bob_balance);\n\n// trusted setup check\nlet result =\nConfidentialTransfer::trusted_setup(Origin::signed(alice_address), k, rng.clone());\nassert_ok!(result);\n\n// proof generation\nlet pp = Plonk::public_parameter().unwrap();\nlet alice_public_key = GENERATOR_EXTENDED * alice_private_key;\nlet bob_public_key = GENERATOR_EXTENDED * bob_private_key;\nlet transfer_amount_scalar = Fp::from(transfer_amount as u64);\nlet alice_after_balance_scalar = Fp::from(alice_after_balance as u64);\n\nlet alice_balance =\nEncryptedNumber::encrypt(alice_private_key, alice_balance.into(), alice_radomness);\nlet alice_transfer_amount = EncryptedNumber::encrypt(\nalice_private_key,\ntransfer_amount.into(),\ntransfer_randomness,\n);\nlet bob_encrypted_transfer_amount =\n(GENERATOR_EXTENDED * transfer_amount_scalar) + (bob_public_key * transfer_randomness);\nlet alice_public_key = JubJubAffine::from(alice_public_key);\nlet bob_public_key = JubJubAffine::from(bob_public_key);\nlet bob_encrypted_transfer_amount = JubJubAffine::from(bob_encrypted_transfer_amount);\nlet bob_encrypted_transfer_amount_other = (GENERATOR_EXTENDED * transfer_randomness).into();\n\nlet confidential_transfer_circuit = ConfidentialTransferCircuit::new(\nalice_public_key,\nbob_public_key,\nalice_balance,\nalice_transfer_amount,\nbob_encrypted_transfer_amount,\nalice_private_key,\ntransfer_amount_scalar,\nalice_after_balance_scalar,\ntransfer_randomness,\n);\nlet prover = PlonkKey::new::&lt;ConfidentialTransferCircuit&gt;(&amp;pp, label)\n.expect(\"failed to compile circuit\");\nlet proof = prover\n.0\n.create_proof(&amp;mut rng, &amp;confidential_transfer_circuit)\n.expect(\"failed to prove\");\n\n// confidential transfer check\nlet transaction_params = ConfidentialTransferTransaction::new(\nalice_public_key,\nbob_public_key,\nalice_transfer_amount,\nbob_encrypted_transfer_amount,\nbob_encrypted_transfer_amount_other,\n);\nlet result = ConfidentialTransfer::confidential_transfer(\nOrigin::signed(alice_address),\nbob_address,\nproof.0,\ntransaction_params,\n);\nassert_ok!(result);\n\n// balance transition check\nlet alice_balance = ConfidentialTransfer::total_balance(&amp;alice_address);\nlet alice_raw_balance = alice_balance.decrypt(alice_private_key);\nlet bob_balance = ConfidentialTransfer::total_balance(&amp;bob_address);\nlet bob_raw_balance = bob_balance.decrypt(bob_private_key);\n\nassert_eq!(alice_raw_balance.unwrap() as u16, alice_after_balance);\nassert_eq!(bob_raw_balance.unwrap() as u16, bob_after_balance);\n})\n}\n</code></pre> <p>With above tests, we can confirm that confidential transfer works correctly. You can check the <code>confidential_transfer</code> example here. Happy hacking!</p>"},{"location":"tutorial/plonk_pallet/","title":"Plonk Tutorial","text":"<p>In this tutorial, we are going to import plonk-pallet to substrate runtime and test its functionalities.</p> <p>The steps are following.</p> <ol> <li>Define the plonk-pallet as depencencies</li> <li>Couple the plonk-pallet to your own pallet</li> <li>Define the plonk-pallet functions on your pallet</li> <li>Import the coupling pallet to TestRuntime and define your Circuit</li> <li>Test whether the functions work correctly</li> </ol>"},{"location":"tutorial/plonk_pallet/#1-define-the-plonk-pallet-as-depencencies","title":"1. Define the plonk-pallet as depencencies","text":"<p>First of all, you need to define the <code>plonk-pallet</code> when you start to implement your pallet. Please define as following.</p> <ul> <li>/Cargo.toml <pre><code>[dependencies]\npallet-plonk = { git = \"https://github.com/KogarashiNetwork/Kogarashi\", branch = \"master\", default-features = false }\njub-jub = { git = \"https://github.com/KogarashiNetwork/Kogarashi\", branch = \"master\", default-features = false }\nzero-plonk = { git = \"https://github.com/KogarashiNetwork/Kogarashi\", branch = \"master\", default-features = false }\nrand_core = {version=\"0.6\", default-features = false }\n</code></pre> <p>The <code>plonk-pallet</code> depends on <code>rand_core</code> so please import it.</p>"},{"location":"tutorial/plonk_pallet/#2-couple-the-plonk-pallet-to-your-own-pallet","title":"2. Couple the plonk-pallet to your own pallet","text":"<p>The next, the <code>plonk-pallet</code> need to be coupled with your pallet. Please couple the pallet <code>Config</code> as following.</p> <ul> <li>/src/main.rs <pre><code>#[frame_support::pallet]\npub mod pallet {\nuse frame_support::pallet_prelude::*;\nuse frame_system::pallet_prelude::*;\npub use plonk_pallet::{FullcodecRng, Proof, PublicInputValue, Transcript, VerifierData};\n\n/// Coupling configuration trait with plonk_pallet.\n#[pallet::config]\npub trait Config: frame_system::Config + plonk_pallet::Config {\n/// The overarching event type.\ntype Event: From&lt;Event&lt;Self&gt;&gt; + IsType&lt;&lt;Self as frame_system::Config&gt;::Event&gt;;\n}\n</code></pre> <p>With this step, you can use the <code>plonk-pallet</code> in your pallet through <code>Module</code>.</p>"},{"location":"tutorial/plonk_pallet/#3-define-the-plonk-pallet-functions-on-your-pallet","title":"3. Define the plonk-pallet functions on your pallet","text":"<p>The next, let's define the <code>plonk-pallet</code> function on your pallet. We are going to define the <code>trusted_setup</code> function which generates the public parameters refered as to <code>srs</code> and the <code>verify</code> function which verified the proof. In this tutorial, we use sum-storage pallet as example and add the <code>verify</code> function before set <code>Thing1</code> storage value on <code>set_thing_1</code>. If the <code>verify</code> is success, the <code>set_thing_1</code> can set <code>Thing1</code> value.</p> <ul> <li>/src/main.rs <pre><code>    // The module's dispatchable functions.\n#[pallet::call]\nimpl&lt;T: Config&gt; Pallet&lt;T&gt; {\n// Coupled trusted setup\n#[pallet::weight(10_000)]\npub fn trusted_setup(\norigin: OriginFor&lt;T&gt;,\nval: u32,\nrng: FullcodecRng,\n) -&gt; DispatchResultWithPostInfo {\npallet_plonk::Pallet::&lt;T&gt;::trusted_setup(origin, val, rng)?;\nOk(().into())\n}\n\n/// Sets the first simple storage value\n#[pallet::weight(10_000)]\npub fn set_thing_1(\norigin: OriginFor&lt;T&gt;,\nval: u32,\nproof: Proof,\npublic_inputs: Vec&lt;Fr&gt;,\n) -&gt; DispatchResultWithPostInfo {\n// Define the proof verification\npallet_plonk::Pallet::&lt;T&gt;::verify(origin, proof, public_inputs)?;\n\nThing1::&lt;T&gt;::put(val);\n\nSelf::deposit_event(Event::ValueSet(1, val));\nOk(().into())\n}\n</code></pre> <p>With this step, we can check whether the proof is valid before setting the <code>Thing1</code> value and only if the proof is valid, the value is set.</p>"},{"location":"tutorial/plonk_pallet/#4-import-the-coupling-pallet-to-testruntime-and-define-your-circuit","title":"4. Import the coupling pallet to TestRuntime and define your Circuit","text":"<p>We already imported the <code>plonk-pallet</code> functions so we are going to import it to <code>TestRumtime</code> and define your customized <code>Circuit</code>.</p> <p>In order to use <code>plonk-pallet</code> in <code>TestRuntime</code>, we need to import <code>plonk-pallet</code> crate and define the pallet config to <code>construct_runtime</code> as following.</p> <ul> <li>runtime/src/main.rs</li> </ul> <pre><code>use crate::{self as sum_storage, Config};\n\nuse frame_support::dispatch::{DispatchError, DispatchErrorWithPostInfo, PostDispatchInfo};\nuse frame_support::{assert_ok, construct_runtime, parameter_types};\n\n// Import `plonk_pallet` and dependency\npub use plonk_pallet::*;\nuse rand_core::SeedableRng;\n\n--- snip ---\n\nconstruct_runtime!(\npub enum TestRuntime where\nBlock = Block,\nNodeBlock = Block,\nUncheckedExtrinsic = UncheckedExtrinsic,\n{\nSystem: frame_system::{Module, Call, Config, Storage, Event&lt;T&gt;},\n// Define the `plonk_pallet` in `contruct_runtime`\nPlonk: plonk_pallet::{Module, Call, Storage, Event&lt;T&gt;},\n{YourPallet}: {your_pallet}::{Module, Call, Storage, Event&lt;T&gt;},\n}\n);\n</code></pre> <p>As the final step of runtime configuration, we define the zk-SNARKs circuit and extend the <code>TestRuntime</code> config with it. You can replace <code>TestCircuit</code> with your own circuit.</p> <ul> <li>runtime/src/main.rs</li> </ul> <pre><code>// Implement a circuit that checks:\n// 1) a + b = c where C is a PI\n// 2) a &lt;= 2^6\n// 3) b &lt;= 2^5\n// 4) a * b = d where D is a PI\n// 5) JubJub::GENERATOR * e(JubJubScalar) = f where F is a Public Input\n\n#[derive(Debug, Default)]\npub struct TestCircuit {\npub a: BlsScalar,\npub b: BlsScalar,\npub c: BlsScalar,\npub d: BlsScalar,\npub e: JubJubScalar,\npub f: JubJubAffine,\n}\n\nimpl Circuit for TestCircuit {\nfn circuit&lt;C&gt;(&amp;self, composer: &amp;mut C) -&gt; Result&lt;(), Error&gt;\nwhere\nC: Composer,\n{\nlet a = composer.append_witness(self.a);\nlet b = composer.append_witness(self.b);\n\n// Make first constraint a + b = c\nlet constraint = Constraint::new().left(1).right(1).public(-self.c).a(a).b(b);\n\ncomposer.append_gate(constraint);\n\n// Check that a and b are in range\ncomposer.component_range(a, 1 &lt;&lt; 6);\ncomposer.component_range(b, 1 &lt;&lt; 5);\n\n// Make second constraint a * b = d\nlet constraint = Constraint::new()\n.mult(1)\n.output(1)\n.public(-self.d)\n.a(a)\n.b(b);\n\ncomposer.append_gate(constraint);\n\nlet e = composer.append_witness(self.e);\nlet scalar_mul_result = composer.component_mul_generator(e, GENERATOR_EXTENDED)?;\ncomposer.assert_equal_public_point(scalar_mul_result, self.f);\nOk(())\n}\n}\n\nimpl plonk_pallet::Config for TestRuntime {\ntype CustomCircuit = TestCircuit;\ntype Event = Event;\n}\n</code></pre> <p>With this step, we finish to setup the plonk runtime environment.</p>"},{"location":"tutorial/plonk_pallet/#5-test-whether-the-functions-work-correctly","title":"5. Test whether the functions work correctly","text":"<p>The plonk functions is available on your pallet so we are going to test them as following tests.</p> <ul> <li>/src/main.rs <pre><code>fn main() {\nlet mut rng = get_rng();\nlet label = b\"verify\";\nlet test_circuit = TestCircuit {\na: BlsScalar::from(20u64),\nb: BlsScalar::from(5u64),\nc: BlsScalar::from(25u64),\nd: BlsScalar::from(100u64),\ne: JubJubScalar::from(2u64),\nf: JubJubAffine::from(GENERATOR_EXTENDED * JubJubScalar::from(2u64)),\n};\n\nnew_test_ext().execute_with(|| {\nassert_eq!(SumStorage::get_sum(), 0);\nassert_ok!(Plonk::trusted_setup(Origin::signed(1), 12, rng.clone()));\n\nlet pp = Plonk::public_parameter().unwrap();\nlet (prover, _) =\nPlonkKey::new::&lt;TestCircuit&gt;(&amp;pp, label).expect(\"failed to compile circuit\");\n\nlet (proof, public_inputs) = prover\n.create_proof(&amp;mut rng, &amp;test_circuit)\n.expect(\"failed to prove\");\n\nassert_ok!(SumStorage::set_thing_1(\nOrigin::signed(1),\n42,\nproof,\npublic_inputs\n));\nassert_eq!(SumStorage::get_sum(), 42);\n})\n}\n</code></pre> <p>With above tests, we can confirm that your pallet is coupling with <code>plonk-pallet</code> and these functions work correctly. You can check the <code>plonk-pallet</code> example here. Happy hacking!</p>"},{"location":"tutorial/reddsa_wallet/","title":"RedDSA Tutorial","text":"<p>In this tutorial, we are going to send transactions through the RedDSA wallet and check whether it was processed correctly. We assume that you already understand what RedDSA Signature is.</p> <p>The steps are following.</p> <ol> <li>Run RedDSA compatible Substrate Node</li> <li>Compile client wallet</li> <li>Generate Wallet</li> <li>Check Balance</li> <li>Transfer Asset</li> </ol> <p>The final goal is to check whether the RedDSA client wallet works through an RPC call to Substrate Node.</p> <p>You can find wallet client here and RedDSA compatible Substrate Node here. We already implemented RedDSA runtime here so you can import this runtime to your Substrate Node.</p>"},{"location":"tutorial/reddsa_wallet/#1-run-reddsa-compatible-substrate-node","title":"1. Run RedDSA compatible Substrate Node","text":"<p>First of all, we would like to run the RedDSA-compatible Substrate Node..</p> <p>Let's clone the RedDSA Substrate Node with the following command.</p> <pre><code>$ git clone git@github.com:KogarashiNetwork/Kogarashi.git\n$ cd Kogarashi\n$ git submodule update -i\n</code></pre> <p>After cloning the repository and submodule dependencies, run the RedDSA Substrate Node with the following command.</p> <ul> <li>Native</li> </ul> <pre><code>$ sh scripts/setup.sh\n</code></pre> <ul> <li>Docker</li> </ul> <pre><code>$ docker-compose up\n</code></pre>"},{"location":"tutorial/reddsa_wallet/#2-compile-client-wallet","title":"2. Compile client wallet","text":"<p>Next, we would like to set up RedDSA Wallet client in here. We can setup with the following command in the root directly.</p> <pre><code>$ rustup target add wasm32-unknown-unknown\n$ cd node/client\n$ cargo build\n</code></pre> <p>And after compilation, we can check whether the wallet client is ready with the following command.</p> <pre><code>$ cargo run list\n</code></pre> <p>If the test accounts list is displayed, the wallet is ready.</p>"},{"location":"tutorial/reddsa_wallet/#3-generate-wallet","title":"3. Generate Wallet","text":"<p>We would like to generate a wallet with the following command.</p> <pre><code>$ cargo run init\n</code></pre> <p>If it's successful in generating a wallet, it would display your address and seed.</p>"},{"location":"tutorial/reddsa_wallet/#4-check-balance","title":"4. Check Balance","text":"<p>Let's check the account balance with the following and whether it's zero.</p> <pre><code>$ cargo run balance\n</code></pre> <p>If you would like to check other account balances, you can do it with the following command.</p> <pre><code>$ cargo run balance {Account Name}\n</code></pre> <p><code>{Account Name}</code> is replaced with 'Alice', and 'Bob' and displayed accounts with <code>cargo run list</code>.</p>"},{"location":"tutorial/reddsa_wallet/#5-transfer-asset","title":"5. Transfer Asset","text":"<p>Finally, we would like to transfer assets but you don't have any assets now so let's fund with the following command.</p> <pre><code>$ cargo run fund\n</code></pre> <p>Right now, you have some assets and can check how much you want with the following command.</p> <pre><code>$ cargo run balance\n</code></pre> <p>Then, let's transfer your asset. We need to decide who and how much we transfer. If you want to transfer 1000 to Bob, it would be the following.</p> <pre><code>$ cargo run transfer Bob 1000\n</code></pre> <p>You can check whether Bob's amount is increased with the following command.</p> <pre><code>$ cargo run balance Bob\n</code></pre> <p>You can find a sample RedDSA implementation here.</p> <p>Happy hacking!</p>"},{"location":"tutorial/reddsa_wallet/#reference","title":"Reference","text":"<p>Zcash Protocol Specification, Version 2022.3.8</p>"}]}